# 변수

# 변수(variable)

정의: 단 하나의 값을 저장할 수 있는 메모리 공간

# 변수의 명명 규칙 4가지

1. 대소문자가 구문되며 길이에 제한이 없다.
2. 예약어를 사용해서는 안된다.
3. 숫자로 시작해서는 안된다.
4. 특수문자는 '_'와 '$'만을 허용한다.

# 변수의 타입

## 기본형과 참조형

**기본형(primitive type):** 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)

**참조형(reference type):** 객체의 주소를 저장한다. 8개의 기본형을 제외한 나머지 타입. 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈이다.

![%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20448e32885e2b4bbfa08d225fe0b8d771/Untitled.png](./img/chapter 2/untitled.png)

기본형(primitive type)

boolean을 제외한 나머지 기본형들은 서로 연산과 변환이 가능하다.

![%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20448e32885e2b4bbfa08d225fe0b8d771/Untitled%201.png](./img/chapter 2/untitled 2.png)

기본형의 크기와 범위

## 상수

상수를 선언할 때는 자료형 앞에 final 붙이면 됨.

상수의 이름은 모두 대문자로 하는 것이 암묵적인 관례이며, 여러 단어로 이루어져있는 경우 '_'로 구분

## 리터럴(literal)

프로그래밍에서 상수를 '값을 한 번 저장하면 변경할 수 없는 저장공간'으로 정의하였기에 이와 구분하기 위해 원래 의미의 상수를 다른 이름으로 불러야만 했다. 그렇게 사용되는 것이 리터럴(literal)이다.

## 타입의 불일치

리터럴의 타입은 저자될 변수의 타입과 일치하는 것이 보통이지만, **타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용**된다.

```jsx
int i = 'A';
long l = 123;
double d = 3.14f;
```

# 진법

## 비트(bit)와 바이트(byte)

![%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20448e32885e2b4bbfa08d225fe0b8d771/Untitled%202.png](./img/chapter 2/untitled 2.png)

bit, byte, word 크기 비교

**워드(word)**는 CPU가 한 번에 처리할 수 있는 데이터의 크기

워드는 CPU 성능에 따라 달라진다. 32비트 CPU에서 1워드는 32비트(4 바이트)이고, 64 비트 CPU에서는 64 비트(8 워드)이다.

## 8진수와 16진수

![%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20448e32885e2b4bbfa08d225fe0b8d771/Untitled%203.png](./img/chapter 2/untitled 3.png)

그림 2-4 2진수를 8진수, 16진수로 변환

1010101100(2) = 1254(8) = 2AC(16)

## 실수의 진법 변환

10진 소수점수를 2진 소수점수로 변환하는 방법은 소수점수에 2를 계속 곱한다.

ex) 0.625

0.625 X 2 = 1.25 → 1

0.25 X 2 = 0.5 → 0

0.5 X 2 = 1.0 → 1

결과: 0.625(10) → 0.101(2)

## 음수의 2진 표현 - 2의 보수법

2진수에서 왼 쪽의 첫 번째 비트(Most Significant Bit, MSB)가 0이면 양수, 1이면 음수다.

2의 보수법으로 표현하면 두 수를 더했을 때 0이 되도록 할 수 있다.

ex)1 + (-1)

0001 + 1111

현재 대부분의 시스템이 2의 보수법으로 부호있는 정수를 표현한다.

### 2의 보수 구하기

(1) 음수의 절대값을 2진수로 변환한다.

(2) (1)에서 구한 2진수의 1을 0으로, 0은 1로 바꾼다.
(3) (2)의 결과에 1을 더한다.

ex) -5의 2진 표현 구하기

(1) 절대값 5의 2진수는 0101

(2) 0101 → 1010(1의 보수)

(3) 1010+1 = 1011(2의 보수 -5)

# 기본형

## 문자형 char

char 타입 변수에는 실제 문자가 아닌 유니코드가 저장된다.

### char 타입의 표현방식

char타입의 크기는 2 byte(16 bit)이므로, 16자리의 2진수로 표현할 수 있는 정수인 65536개의 코드를 사용할 수 있다. char형 변수는 이 범위 내의 코드 중 하나를 저장할 수 있다.

### 인코딩과 디코딩

문자 인코딩(encoding): 문자 → 코드

문자 디코딩(decoding): 코드 → 문자

어떻게 인코딩을 했는지를 알아야 디코딩이 가능하다. 유니코드와 같은 코드표가 필요하다.

코드표 예: 아스키(ASCII), 확장 아스키(Extended ASCII), 코드 페이지(code page, cp), 유니코드(Unicode)

## 정수형 - byte, short, int, long

크기 배열 byte(1) < short(2) < int(4) < long(8)

기본 자료형은 int

## 실수형 - float, double

float 타입의 표현범위는 -3.4 x 10^38 ~ 3.4 x 10^38이지만, -1.4 x 10^-45 ~ 1.4 x 10^-45 범위의 값은(0 제외) 표현할 수 없다. 얼마나 0에 가깝게 표현할 수 있는가도 중요하다.

실수형은 **'부호(S), 지수(E), 가수(M)'** 세 부분으로 이루어져 있다. 때문에 **'2의 제곱을 곱한 형태(+-M x 2^E)'**으로 저장된다.

double 타입은 float 타입보다 정밀도가 약 2배인, 15자리의 정밀도를 가지므로 float 타입보다 정밀하다.

# 형변환

 형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환

Primitive type에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능하다.

기본형과 참조형간의 형변환은 불가능하다.

## 정수형간의 형변환

int를 byte로 변환하는 경우는 크기의 차이만큼 잘려나간다. 그래서 경우에 따라 '값 손실'이 발생할 수 있다.

![%E1%84%87%E1%85%A7%E1%86%AB%E1%84%89%E1%85%AE%20448e32885e2b4bbfa08d225fe0b8d771/Untitled%204.png](./img/chapter 2/untitled 4.png)

표 2-21 int → byte 형변환 값손실 예제

작은 타입에서 큰 타입으로 변환하는 경우 생기는 빈 공간은 0 또는 1로 채워진다.