# 6장. 키-값 저장소 설계

키-값 저장소(key-value store)는 기-값 데이터베이스라고 도 불리는 비 관계형(non -relational) 데이터베이스이다.

고유 식별자(identifier)를 키로 가져야 한다.

키와 값 사이의 이런 연결 관계를 키-값 쌍(pair)라고 지칭한다.

**사례`**

- 일반 텍스트 키: “last_logged_int_at”
- 해시 키: 253DDEC4

**객체**

- put(key, value): 기-값 쌍을 저장소에 저장한다.
- get(key): 인자로 주어진 키에 매달린 값을 꺼낸다.

# 문제 이해 및 설계 범위 확정

이번 장에서 설계할 저장소 조건

- 키-값 쌍의 크기는 10KB 이하이다.
- 큰 데이터를 저장할 수 있어야 한다.
- 높은 가용성을 제공해야 한다. 따라서 시스템은 설사 장애가 있더라도 빨리 응답해야 한다.
- 높은 규모 확장성을 제공해야 한다. 따라서 트래픽 양에 따라 자동적으로 서버 증설/삭제가 이루어져야 한다.
- 데이터 일관성 수준은 조정이 가능해야 한다.
- 응답 지연시간(latency)이 짧아야 한다.

# 단일 서버 키-값 저장소

가장 직관적인 설계 방법은 키-값 쌍 전부를 한 대 서버 내 메모리에 해시 테이블로 저장

- 장점: 빠른 속도
- 단점: 모든 데이터를 메모리 안에 두는 것이 불가능 할 수 있음
- 해결책
- 데이터 압축(compression)
- 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

# 분산 키-값 저장소

분산 해시 테이블이라고도 불린다. 분산 시스템을 설계할 때는 CAP 정리(Consistency, Availability, Partition Tolerance theorem)를 이해하고 있어야 한다.

## CAP 정리

CAP 정리는 데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리.

- **데이터 일관성(consistency)**: 모든 클라이언트는 어떤 노드에 접속했느냐에 관계없이 언제나 같은 데이터를 보게 되어야 한다.
- **가용성(availability)**: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다.
- **파티션 감내(partition tolerance)**: 파티션이 발생하더라도 시스템은 계속 동작해야 한다.

> 파티션이란 두 노드 사이에 통신 장애가 발생했음을 의미
> 

![Untitled](6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%2098ba9/Untitled.png)

위 그림은 어떤 두 가지를 충족하려면 나머지 하나는 반드시 희생되어야 함을 의미

- CP 시스템: 일관성과 파티션 감내를 지원하는 키-값 저장소. 가용성을 희생.
- AP 시스템: 가용성과 파티션 감내를 지원하는 키-값 저장소. 데이터 일관성 희생.
- CA 시스템: 일관성과 가용성을 지원하는 키-값 저장소. 파티션 감내 희생.

분산 시스템은 반드시 Partion Tolerance를 지원해야 하므로 CA 시스템은 존재하지 않음

### 이상적 상태

이상적 환경이라면 네트워크가 파티션되는 상황은 절대로 일어나지 않음

n1 서버에 기록된 내용은 n2, n3에 복제됨

### 실세계의 분산 시스템

분산 시스템은 파티션 문제를 피피할 수 없다.

파티션 문제가 발생하면 일관성과 가용성 둘 중 하나를 선택해야 한다.

![Untitled](6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%2098ba9/Untitled%201.png)

그림에서 n3 서버가 장애가 발생한 경우 n3에는 있으나 n1, n2에 없는 데이터가 있다면 n1, n2는 최신화되지 않은 데이터 사본을 갖고 있는 상태이다.

- 가용성 대신 일관성을 선택한다면 세 서버 사이에 생길 수 있는 데이터 불일치 문제를 피하기 위해 n1과 n2에 대해 쓰기 연산을 중단시켜야 한다. → 가용성이 깨진다. ex) 은행권 시스템은 최신화된 계좌 정보만 제공해야 함.

## 시스템 컴포넌트

키-값 저장소 구현에 사용될 핵심 컴포넌트들

- 데이터 파티션
- 데이터 다중화(replication)
- 일관성(consistency)
- 일관성 불일치 해소(inconsistency resolution)
- 장애 처리
- 시스템 아키텍처 다이어그램
- 쓰기 경로(write path)
- 읽기 경로(read path)

### 데이터 파티션

전체 데이터를 한 대 서버에 욱여넣는 것은 불가능

가장 단순한 해결책은 데이터를 작은 파티션들로 분할한 다음 여러 대 서버에 저장

다음 사항들 고려

- 데이터를 여러 서버에 고르게 분산할 수 있는가
- 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가

안정해시(consistent hash)는 이런 문제를 푸는 데 적합하다.

**안정 해시를 사용한 데이터 파티션 장점**

- 규모 확장 자동화(automatic scaling): 시스템 부하에 따라 서버가 자동으로 추가 또는 삭제
- 다양성(heterogeneity): 각 서버 용량에 맞춰 가상 노드 수 조정

### 데이터 다중화

높은 가용성과 안정성을 확보하기 위해서는 데이터를 N개(N은 튜닝 가능한 값) 서버에 비동기적으로 다중화(replication)할 필요가 있다.

어떤 키를 해시 링 위에 배치한 후, 그 지점으로부터 시계 방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관한다.

N=3으로 설정하면 key0는 s1, s2, s3에 값을 저장한다.

가상 노드 사용한다면 노드 개수가 실제 물리 서버보다 많아질 수 있다.

이럴 때는 노드를 선택할 때 같은 물리 서버를 중복 선택하지 않도록 주의해야 한다.

### 데이터 일관성

여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 한다. 

정족수 합의(Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두 일관성 보장 가능하다.

- N = 사본 개수.
- W = 쓰기 연산에 대한 정족수. 최소 W개 이상의 서버에서 쓰기 연산 성공 필요.
- R = 읽기 연산에 대한 정족수. 최소 R개 이상의 서버에서 쓰기 연산 성공 필요.

![Untitled](6%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B5-%E1%84%80%E1%85%A1%2098ba9/Untitled%202.png)

위 그림은 N=3인 경우의 그림이다. W=1일 경우 중재자(coordinate)는 s0, s1, s2 셋 중 최소 하나의 서버로부터 쓰기 성공 응답을 받아야 한다는 뜻이다. 그러므로 s1로부터 쓰기 응답을 받을 경우 s0, s2로부터 쓰기 응답을 기다릴 필요가 없어진다.

중재자(coordinator)는 클라이언트와 노드 사이에서 프록시(proxy) 역할을 한다.

- R=1, W=N : 빠른 읽기 연산에 최적화된 시스템
- R=N, W=1: 빠른 쓰기 연산에 최적화된 시스템
- W+R < N일 경우 강한 일관성 보장 안됨
- W+R > N일 경우 강한 일관성 보장 (보통  N=3, W=R=2)
→ 일관성을 보증할 최신 데이터를 가진 노드가 최소 하나는 겹치기 때문

**일관성 모델**

일관성 모델(consistency model)은 키-값 저장소를 설계할 때 고려

- 강한 일관성(strong consistency): 모든 읽기 연산은 가장 최근에 갱신된 결과 반환. 클라이언트는 구버전 데이터를 볼 수 없음.
- 방법1: 모든 사본에 현재 쓰기 연산의 결과가 반영될 때까지 읽기/쓰기 금지 - 고가용성에 적합하지 않음.
- 약한 일관성(week consistency): 읽기 연산은 가장 최근에 갱신된 결과를 반환하지 못할 수 있음.
- 최종 일관성(eventual consistency): week consistency의 한 형태로, 갱신 결과가 결국 모든 사본에 반영되는 모델.
일관성이 깨질 경우 클라이언트 측에서 데이터의 버전 정보를 활용해 일괄성이 깨진 데이터를 읽지 않도록 해야함

**비 일관성 해소 기법: 데이터 버저닝**

데이터를 다중화할 경우 가용성 증가, 일관성 감소

버저닝(versioning), 벡터 시계(vector clock)는 그 문제를 해소하기 위해 등장

버저닝은 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만드는 것 
→ 각 버전의 데이터는 변경 불가(immutable)