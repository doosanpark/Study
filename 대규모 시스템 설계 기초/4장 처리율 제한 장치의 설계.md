# 4장. 처리율 제한 장치의 설계

처리율 제한 장치(rate limiter)는 클라이언트 또는 서비스가 보내는 트래픽의 처리율(rate)을 제어하기 위한 장치

 API 요청 횟수가 임계치에 도달하면 추가 호출은 중단됨

**예시**

- 초당 2회 이상 새 글을 올릴 수 없다.
- 같은 IP 주소로는 하루 10개 이상의 계정을 생성할 수 없다.
- 같은 디바이스로는 주당 5회 이상 리워드(reward)를 요청할 수 없다.

**장점**

- DosS 공격에 의한 자원고갈 방지
- 비용 절감
- 추가 요청에 대한 처리 제한 시 서버 수 절약 가능하며 API를 우선순위에 따라 자원할당 가능
- 서버 과부하 방지

# 1단계 문제 이해 및 설계 범위 확정

질의응답을 통해 시스템 요구사항 설정

**요구사항 예시**

- 제한해야 하는 처리에 대해 명확한 기준을 세운다.
- 설정된 처리율을 초과하는 요청은 정확하게 재한한다.
- 낮은 응답시간: 이 처리율 제한 장치는 HTTP 응답시간에 나쁜 영향을 주어서는 곤란한다.
- 가능한 한 적은 메모리를 써야 한다.
- 분산형 처리율 제한: 하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유할 수 있어야 한다.
- 예외 처리: 요청이 제한되었을 때는 그 사실을 사용자에게 분명하게 보여주어야 한다.
- 높은 결함 감내성(fault tolerance): 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안된다.

# 2단계 개략적 설계안 제시 및 동의 구하기

일은 복잡하지 않고 간단하게 하도록 한다.

기본적인 클라이언트-서버 통신 모델을 사용하도록 한다.

**처리율 제한 장치는 어디에 둘 것인가?**

- 클라이언트 - 안정적이지 않음.
- 서버
- 미들웨어 생성 - HTTP 상태 코드 429(Too many rquests) 반환

MS의 경우 처리율 제한장치는 보통 API 게이트웨이 컴포넌트에 구현

## 처리율 제한 알고리즘

- 토큰 버킷
- 누출 버킷
- 고정 윈도 카운터
- 이동 윈도 로그
- 이동 윈도 카운터

### 토큰 버킷 알고리즘

1. 주기적인 토큰 공급
2. 요청 전달
3. 요청 수와 토큰 수 비교
4. 요청 수 > 토큰 수일 경우 토큰의 선택을 받지 못한 요청 반려

**parameter**
- 버킷 크기: 버킷에 담을 수 있는 토큰 최대 개수
- 토큰 공급률(refill rate): 초당 몇 개의 토큰이 버킷에 공급되는가

**버킷 개수**
- API 엔드포인트(endpoint)마다 버킷 설정
 - IP 주소마다 버킷 - IP 주소별 처리율 제한

**장점**

- 쉬운 구현
- 효율적 메모리 사용
- burst of traffic 처리 가능 - 남은 토큰만 있다면 요청은 시스템에 전달

**단점**

- 버킷 크기와 토큰 공급률을 적절한 비율로 튜닝하는 것이 쉽지 않음

### 누출 버킷 알고리즘

토큰 버킷 알고리즘과 비슷하지만 요청 처리율이 고정되어 있음

**작동원리**

- 요청이 도착하면 큐가 가득 차 있는지 확인. 빈자리가 있으면 큐에 요청 추가.
- 큐가 가득 차 있는 경우에는 새 요청은 버림.
- 지정된 시간마다 큐에서 요청을 꺼내 처리.

**파라미터**

버킷크기: 큐 사이즈와 같은 값. 큐에는 처리될 항목 보관

처리율(outflow rate): 지정된 시간당 몇 개의 항목을 처리할지 지정하는 값. 초 단위로 표현.

**장점**

- 큐의 크기가 제한되어 있어 메모리 사용량 측면에서 효율적
- 고정된 처리율 때문에 안정적 출력(stable outflow rate) 필요한 경우에 적합

**단점**

- 단시간에 많은 트래픽이 몰리면 오래된 요청들이 쌓이고, 제때 처리 못하면 최신 요청들 버려짐
- 두 개 인자를 갖고 있는데, 올바르게 튜닝하기 까다로울 수 있음

### 고정 윈도 카운터 알고리즘

- 타임라인(timeline)을 고정된 간격의 윈도(window)로 나누고, 각 윈도마다 카운터(counter) 붙임
- 요청이 접수될 때마다 카운터의 값 1씩 증가
- 카운터 값이 사정에 설정된 임계치(threshold)에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려짐

 **장점**

- 메모리 효율이 좋다.
- 이해하기 쉽다.
- 윈도가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합하다.

**단점**

- 윈도 경계 부근에서 일시적으로 많은 트래픽이 몰려드는 경우, 기대했던 시스템의 처리 한도보다 많은 양의 요청을 처리하게 된다.

### 이동 윈도 로깅 알고리즘

고정 윈도 카운터 알고리즘의 문제를 개선한 알고리즘

- 타임스탬프 추적
타임스탬프 데이터는 보통 레디스(Redis)의 정렬 집합(sorted set) 같은 캐시에 보관
- 새 요청이 오면 만료된 타임스탬프 제거
현재 윈도 시작지점보다 오래된 타임스탬프는 모두 만료처리
- 새 요청의 타임스탬프를 로그(log)에 추가
- 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달

**장점**

- 어느 순간의 윈도를 보더라도, 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않음

**단점**

- 거부된 요청 타임스탬프도 보관하기에 다량의 메모리 사용

### 이동 윈도 카운터 알고리즘

고정 윈도 카운터 알고리즘 + 이동 윈도 로깅 알고리즘

이전 시간대의 평균 처리율에 따라 현재 윈도의 상태 계산

**요청 수 계산 공식**: 직전 1분간의 요청 수  X 이동 윈도와 직전 1분이 겹치는 비율 +현재 1분간의 요청 수 

**장점**

- 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.
- 메모리 효율이 좋다.

**단점**

- 추정치를 계산하기 때문에 오차가 있을 수 있다.
- 오차율은 대략 0.003%정도

# 3단계 상세 설계

### 처리율 제한 규칙 예시

- 마케팅 메시지 최대치 하루 5개 제한
- 분당 5회 이상 로그인 불가

### 처리율 한도 초과 트래픽의 처리